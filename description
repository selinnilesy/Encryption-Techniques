Lab Exam 3 Preliminary (2019)
Due date: Saturday, 27 April 2019, 10:55 PM
Requested files: exam_3_0_copy.h, exam_3_0.c, run.c (Download)
Type of work: Individual work
SECURE COMMUNICATION
In this lab exam, you are going to implement encrypton functions to encrypt given strings which is mandatory for secure communications.

You cannot use any library other than the given libraries (including string.h).

Do not use static keyword, do not write static in anywhere in your solution, not even in comments or as a part of a variable name.

You are not allowed to use static defined arrays. Instead, you will get the memory by using "malloc", "calloc", and "realloc". See example usages below:

char temp[10]; // FORBIDDEN
char* temp2 = malloc(10 * sizeof(char)); // ALLOWED
/* below usages DOES NOT mean you are using static arrays, you can write in any way you want */
temp2[0] = 'x'; // ALLOWED
temp2[1] = 'y'; // ALLOWED
*(temp2 + 2) = 'z'; // ALLOWED
You are not allowed to allocate more space than is actually required. You may use "realloc" to re-allocate space when it is required in functions. However, you are not supposed to allocate a very large space and then decrease the size with "realloc".

Each call to "malloc", "calloc" and "realloc" will be automatically investigated to check for extra memory usage. Therefore, you *MAY NOT GET A GRADE* from a function implementation if your memory usage is invalid. Don't forget to "free" the memory you allocated for temporary use; however, this does not mean that you should free everything you allocated. If you allocate memory for holding strings, then you should not free the memory to use them later on.

Do not change the given "include" and "define" lines in the solution file (exam_3_0.c), start coding after:

/* DON'T TOUCH THE CODE ABOVE, INCLUDING THIS LINE. YOUR IMPLEMENTATIONS MAY START BELOW THIS LINE. */
You need to provide empty definitions for all the functions even if you do not want them to be graded. Otherwise, compiler gives an "undefined reference" error.

A copy of the header file that contains the function prototypes is also provided as "exam_3_0_copy.h" 

This file is not used in evaluation.

Any change in this file will have no effect in run, debug or evaluate commands.

You can copy it to work locally.

You can use "run.c" file for testing your functions with run and debug commands, modify it however you like.

This file is not used in evaluation.

Do not print anything in your implementations (in exam_3_0.c), just return proper values. You can print anything you want in run.c file for testing purposes.

***IMPORTANT NOTES REGARDING QUESTIONS***

Note 1: It is *STRONGLY* recommended to study this question before Lab Exam 3. Many cases that are mentioned below will be checked. Read question carefully. Prepare well.

Note 2: Find a way to utilize your function implementations. You can implement any helper functions you want. Implementing helper functions for doing similar jobs will speed you up in the lab exam. That is why it is recommended to prepare well for the lab exam 3.

Note 3: To understand what functions do, you should examine exam_3_0_copy.h. You will find explanations for the functions. Know that you can use one function in another function to make things easier for you.

Note 4: In case you want to check whether you implemented your functions correctly, you should use run.c file to call your implementations. Make sure you don't delete implementations of utility functions given in the beginning.

1. SCENARIOS

For secure communication, the message should not be understood even it is captured. To do so, it must be encrypted with some reversible method. In cryptography, a cipher is an algorithm for performing encryption or decryption--a series of well-defined steps that can be followed as a procedure.

Caesar's cipher: The Caesar Cipher, also known as a shift cipher, is one of the oldest and simplest forms of encrypting a message. It is a type of substitution cipher where each letter in the original message (which in cryptography is called the plaintext) is replaced with a letter corresponding to a certain number of letters shifted up or down in the alphabet. 

Polyalphabetic cipher: A polyalphabetic cipher is similar to Caesar's cipher, whereas shifting is done by a given key text.

Combine strings: Generating string by combining strings with a given grouping.

MyCipher: It is a new cipher, we made it up. 

You will implement functions to carry out above procedures.

i. Caesar's Cipher

The Caesar cipher is one of the earliest known and simplest ciphers. It is a type of substitution cipher in which each letter in the plaintext is 'shifted' a certain number of places down the alphabet. For example, with a shift of 1, 'A' would be replaced by 'B', 'B' would become 'C', and so on. The method is named after Julius Caesar, who apparently used it to communicate with his generals. Shifting number may be changed. If shifting number is 3, 'A' is replaced with 'D'. Be careful, only letters are shifted. Other characters are kept same. To decrypt the encrypted message, shifting is done with reverse. If shifting number is 3, each word is shifted with -3 to decrypt the message.

caesar cipher
ii. Polyalphabetic Cipher

It is similar to Caesar's cipher with a difference. Instead of using predefined shifting number, a string key is used for each character. For example, let "ceng” be the key. The number of the character in the alphabet is used as [3, 5, 14, 7]. If the message to encrypt is "Nothing is true”, 'N' is shifted with 3, 'o' is shifted with 5, 't' is shifted with 14, 'h' is shifted with 7 and then it returns to beginning as 'i' is shifted with 3 and goes on until the end of the message. Be careful, only letters are shifted. Other characters are kept same and the key is not used for them. To decrypt the encrypted message, shifting in reverse way is enough.

polyalphabetic cipher

iii. Combining Strings

Combining messages makes harder to get the meaning of captured message even it is decrypted. Eavesdropper must capture all strings to reveal the hidden message. If you send these combined messages with different channels, enemy must own all of these channels. This method will combine given strings with a grouping and return the combined strings with a char**. Salt string is given for padding the strings. All strings will be completed with the salt up to length longer than the longest message which is divisible by grouping*n_string.

grouping-strings
In the example, the longest string is length of 15 and the padding string is ceng. The length of all strings after padding must be same and divisible by 12 which is grouping*number_of_messages. 24 is the first number after 15 which is the length of longest string. Therefore, each message is padded with ceng up to 24. Since grouping is 4, 4 characters are retrieved from each message to generate a combination. First combination is started with the first 4 characters of first message and continues with the second 4 characters of the second message and goes on. Second combination is started with the first 4 characters of the second message and continues with the second 4 characters of the third message etc. Colors represent which combination the group belongs to.

iv. MyCipher

MyCipher is a fictional cipher that takes multiple messages to encrypt. First, it combines strings and then use one of Caesar's cipher or Polyalphabetic Cipher to encrypt them.  Cipher method that sent as parameter is applied to each combination that returns by combine_string method. Returns char** which are the encrypted messages for each combination.



Some Hints

Check utility functions for complementing operations, these are already implemented for you to use them.

ASCII table is used for shifting. Be sure that your program is case sensitive.

'A':65, 'Z':90, 'a':97, 'z':122

You will not shift any non-alphabetic character. Namely; only [a-zA-Z]. Spaces, numbers, punctuations etc. will be ignored. For polyalphabetic cypher, key will be used for only alphabetic characters.

'A' and 'a' are both 1, 'Z' and 'z' are both 26 for shifting key.

If shifting a character, exceeds the range of the lowercase or uppercase characters, then simply take the remainder(mod) according to case of the character.



3. UTILITY FUNCTIONS

There are utility functions that are implemented for you to use in the lab exam:

get_string_length: Returns number of characters in a string. (similar to strlen in string.h)

get_longest_string_length: Returns the length of the longest string from the given strings.

print_combined_strings: Prints combined strings one line for each.

is_letter: Returns whether given char is letter or not.

letter_to_shift: Returns the order of the letter in the alphabet.

It is *STRONGLY RECOMMENDED* to use utility functions to speed you up. However, it is *PROHIBITED* to change signature and implementation of these functions.



4. Caesar's Cipher Encrypt

char* caesar_encrypt(char* message_to_encrypt, void* shift);
This function should take message_to_encrpyt(char*), shift(int*) and create an encrypted string (char*).You should cast shşft into (int*) before use. After casting you can reach the value inside the pointer by deferencing it. When message_to_encrypt is NULL, return NULL and do nothing. Otherwise, encrypt the string. However, be sure that you do not change the original message, you get new space for the encrypted string. See Caesar's Cipher section above to understand the method.

message_to_encrypt: "Nothing is true. Everything is permitted."
shift: 3
encrypted_message: Qrwklqj lv wuxh. Hyhubwklqj lv shuplwwhg.
Please examine exam_3_0_copy.h carefully, to understand what you will return in each case. All cases will be tested. You will see that this function

Returns NULL when message_to_encrypt is NULL,

Returns encrypted_message (char*) when encryption is done successfully.



4. Polyalphabetic Cipher Encrypt

char* polyalphabetic_encrypt(char* message_to_encrypt, void* key_string);
This function should take message_to_encrpyt(char*) and key_string(void*) to create an encrypted string (char*). You should cast key_string into (char*) before use. After casting you can reach the value inside the pointer by deferencing it. When message_to_encrypt is NULL, return NULL and do nothing. Otherwise, encrypt the string. Otherwise, encrypt the string. However, be sure that you do not change the original message, you get new space for the encrypted string. See Polyalphabetic Cipher section above to understand the method.

message_to_encrypt: "Nothing is true. Everything is permitted."
key: "Ceng”
encrypted_message: "Qtholsu pv yfbh. Jjludholsu pv usypnhahi."
Please examine exam_3_0_copy.h carefully, to understand what you will return in each case. All cases will be tested. You will see that this function

Returns NULL when message_to_encrypt is NULL,

Returns encrypted_message (char*) when encryption is done successfully.



5. Combining Strings

char** combine_strings(char** messages, int n_messages, int grouping, char* salt);
This function should combine given strings with grouping. If any string is shorter than the others, it is padded with given salt string up to longest message's length+n where longest message's length+n is divisible to grouping*n_messages. However, be sure that original strings are not changed. See Combining Strings section above to understand the method.

messages: "I have a pen”
	     "I have an apple”
	     "Uhh apple pen”
n_messages: 3
grouping: 4
salt: "ceng”

combined_messages: "I have ae pecengengcgcen"
                   "I haappl penplecgcenceng"
                   "Uhh ve an apncencengengc"
Please examine exam_3_0_copy.h carefully, to understand what you will return in each case. All cases will be tested. You will see that this function

Returns NULL when any of messages is NULL,

Returns combined_messages (char**) when combination is done successfully.

5. MyCipher

char** mycipher_encrypt(char** messages, int n_messages, int grouping, char* salt, char*(*cipher_method)(char*, void*), void* shift);
This function gets messages to encrypt and combines them. For each combined string, given cipher method is used. Cipher method is sent as parameter as you see in the signature. Be sure that original strings are not changed. shift_number is used only if cipher method is Caesar's and shift_key is used only if cipher_method is polyalphabetic. See MyCipher section above to understand the method.

messages: "I have a pen”
	     "I have an apple”
	     "Uhh apple pen”
n_messages: 3
grouping: 4
salt: "ceng"
cipher_method: caesar_encrypt
shift_number: 3

encrypted_messages: "L kdyh dh shfhqjhqjfjfhq"
                    "L kddsso shqsohfjfhqfhqj"
                    "Uhh ve an apncencengengc"
Please examine exam_3_0_copy.h carefully, to understand what you will return in each case. All cases will be tested. You will see that this function

Returns NULL when any of messages is NULL,

Returns encrypted_messages (char**) when combination is done successfully.
